#  几种常用的设计模式介绍

[TOC]

**几种常用的设计模式介绍**

# 1.     设计模式的起源

最早提出“设计模式”概念的是建筑设计大师亚力山大Alexander。在1970年他的《建筑的永恒之道》里描述了投计模式的发现，因为它已经存在了千百年之久，而现代才被通过大量的研究而被发现。

在《建筑的永恒之道》里这样描述：模式是一条由三个部分组成的通用规则：它表示了**一个特定环境**、**一类问题**和**一个解决方案**之间的关系。每一个模式描述了一个**不断重复发生**的问题，以及该问题**解决方案的核心设计**。

 

在他的另一本书《建筑模式语言》中提到了现在已经定义了253种模式。比如：

说明城市主要的结构：亚文化区的镶嵌、分散的工作点、城市的魅力、地方交通区

住宅团组：户型混合、公共性的程度、住宅团组、联排式住宅、丘状住宅、老人天地室内环境和室外环境、阴和阳总是一气呵成

针对住宅：夫妻的领域、儿童的领域、朝东的卧室、农家的厨房、私家的沿街露台、个人居室、起居空间的序列、多床卧室、浴室、大储藏室

针对办公室、车间和公共建筑物：灵活办公空间、共同进餐、共同小组、宾至如归、等候场所、小会议室、半私密办公室

 

尽管亚力山大的著作是针对建筑领域的，但他的观点实际上适用于所有的工程设计领域，其中也包括软件设计领域。“软件设计模式”，这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。目前主要有23种。

 

# 2.     软件设计模式的分类

## 2.1.  创建型

创建对象时，不再由我们直接实例化对象；而是根据特定场景，由程序来确定创建对象的方式，从而保证更大的性能、更好的架构优势。创建型模式主要有**简单工厂模式**（并不是23种设计模式之一）、**工厂方法、抽象工厂模式**、**单例模式**、生成器模式和原型模式。

## 2.2.  结构型

用于帮助将多个对象组织成更大的结构。结构型模式主要有适配器模式adapter、**桥接模式****bridge**、组合器模式component、装饰器模式decorator、**门面模式**、亨元模式flyweight和**代理模式****proxy**。

## 2.3.  行为型

用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。行为型模式主要有**命令模式command**、解释器模式、迭代器模式、中介者模式、备忘录模式、**观察者模式**、状态模式state、**策略模式**、模板模式和访问者模式。

# 3.     常见设计模式介绍

## 3.1.  单例模式(singleton)

有些时候，允许自由创建某个类的实例没有意义，还可能造成系统性能下降。如果一个类始终只能创建一个实例，则这个类被称为单例类，这种模式就被称为单例模式。

​    一般建议单例模式的方法命名为：getInstance()，这个方法的返回类型肯定是单例类的类型了。getInstance方法可以有参数，这些参数可能是创建类实例所需要的参数，当然，大多数情况下是不需要的



单例模式主要有如下两个优势：

1)       减少创建Java实例所带来的系统开销

2)       便于系统跟踪单个Java实例的生命周期、实例状态等。

 

## 3.2.  简单工厂(StaticFactory Method)

简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。

A实例调用B实例的方法，称为A依赖于B。如果使用new关键字来创建一个B实例（硬编码耦合），然后调用B实例的方法。一旦系统需要重构：需要使用C类来代替B类时，程序不得不改写A类代码。而用工厂模式则不需要关心B对象的实现、创建过程。



Output，接口



Printer，Output的一个实现



BetterPrinter，Output的一个实现



OutputFactory，简单工厂类



Computer



 

使用简单工厂模式的优势：让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。从而避免了对象的调用者与对象的实现类以硬编码方式耦合，以提高系统的可维护性、可扩展性。工厂模式也有一个小小的缺陷：当产品修改时，工厂类也要做相应的修改。

## 3.3.  工厂方法(Factory Method)和抽象工厂(Abstract Factory)

如果我们不想在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂，不同的工厂类和产不同的产品。

当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合，如：



 

使用简单工厂类，需要在工厂类里做逻辑判断。而工厂类虽然不用在工厂类做判断。但是带来了另一种耦合：客户端代码与不同的工厂类耦合。

 

为了解决客户端代码与不同工厂类耦合的问题。在工厂类的基础上再增加一个工厂类，该工厂类不制造具体的被调用对象，而是制造不同工厂对象。如：



 

## 3.4.  代理模式(Proxy)

代理模式是一种应用非常广泛的设计模式，当客户端代码需要调用某个对象时，客户端实际上不关心是否准确得到该对象，它只要一个能提供该功能的对象即可，此时我们就可返回该对象的代理（Proxy）。



代理就是一个Java对象代表另一个Java对象来采取行动。如：



调用时，先不创建：



 

Hibernate默认启用延迟加载，当系统加载A实体时，A实体关联的B实体并未被加载出来，A实体所关联的B实体全部是代理对象——只有等到A实体真正需要访问B实体时，系统才会去数据库里抓取B实体所对应的记录。

借助于Java提供的Proxy和InvocationHandler，可以实现在**运行时生成动态代理**的功能，而动态代理对象就可以作为目标对象使用，而且增强了目标对象的功能。如：

Panther



GunPanther



MyProxyFactory，创建代理对象



MyInvokationHandler，增强代理的功能



TxUtil



测试



Spring所创建的AOP代理就是这种动态代理。但是Spring AOP更灵活。

## 3.5.  命令模式(Command)

某个方法需要完成某一个功能，完成这个功能的大部分步骤已经确定了，但可能有少量具体步骤无法确定，必须等到执行该方法时才可以确定。（在某些编程语言如Ruby、Perl里，允许传入一个代码块作为参数。但Jara暂时还不支持代码块作为参数）。在Java中，传入该方法的是一个对象，该对象通常是某个接口的匿名实现类的实例，该接口通常被称为命令接口，这种设计方式也被称为命令模式。



如：

Command



ProcessArray



TestCommand



 

HibernateTemplate使用了executeXxx()方法弥补了HibernateTemplate的不足，该方法需要接受一个HibernateCallback接口，该接口的代码如下：



 

## 3.6.  策略模式(Strategy)

策略模式用于封装系列的算法，这些算法通常被封装在一个被称为Context的类中，客户端程序可以自由选择其中一种算法，或让Context为客户端选择一种最佳算法——使用策略模式的优势是为了支持算法的自由切换。



DiscountStrategy，折扣方法接口



OldDiscount，旧书打折算法



VipDiscount，VIP打折算法



策略定义



测试



使用策略模式可以让客户端代码在不同的打折策略之间切换，但也有一个小小的遗憾：客户端代码需要和不同的策略耦合。为了弥补这个不足，我们可以考虑使用配置文件来指定DiscountContext使用哪种打折策略——这就彻底分离客户端代码和具体打折策略类。

## 3.7.  门面模式(Facade)

随着系统的不断改进和开发，它们会变得越来越复杂，系统会生成大量的类，这使得程序流程更难被理解。门面模式可为这些类提供一个简化的接口，从而简化访问这些类的复杂性。

​       门面模式（Facade）也被称为正面模式、外观模式，这种模式用于将一组复杂的类包装到一个简单的外部接口中。



 

原来的方式



门面模式



门面模式调用



## 3.8.  桥接模式(Bridge)

由于实际的需要，某个类具有两个以上的维度变化，如果只是使用继承将无法实现这种需要，或者使得设计变得相当臃肿。而桥接模式的做法是**把变化部分抽象出来**，使变化部分与主类分离开来，从而将多个的变化彻底分离。最后**提供一个管理类来组合不同维度上的变化**，通过这种组合来满足业务的需要。





Peppery口味风格接口：



口味之一



口味之二



口味的桥梁



材料之一，继承口味



材料之二，继承口味



主程序



Java EE应用中常见的DAO模式正是桥接模式的应用。

实际上，一个设计优良的项目，本身就是设计模式最好的教科书，例如Spring框架，当你深入阅读其源代码时，你会发现这个框架处处充满了设计模式的应用场景。

http://www.cnblogs.com/liuling/archive/2013/04/20/observer.html

## 3.9.  观察者模式(Observer)

　观察者模式结构中包括四种角色：

　　一、主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如添加、删除观察者以及通知观察者更新数据的方法。

　　二、观察者：观察者也是一个接口，该接口规定了具体观察者用来更新数据的方法。

　　三、具体主题：具体主题是一个实现主题接口的类，该类包含了会经常发生变化的数据。而且还有一个集合，该集合存放的是观察者的引用。

　　四：具体观察者：具体观察者是实现了观察者接口的一个类。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，让自己成为它的观察者，或者让这个具体主题将自己从具体主题的集合中删除，使自己不在时它的观察者。

 

观察者模式定义了对象间的一对多依赖关系，让一个或多个观察者对象观察一个主题对象。当主题对象的状态发生变化时，系统能通知所有的依赖于此对象的观察者对象，从而使得观察者对象能够自动更新。

在观察者模式中，被观察的对象常常也被称为目标或主题（Subject），依赖的对象被称为观察者（Observer）。



Observer，观察者接口：

观察者：观察者也是一个接口，该接口规定了具体观察者用来更新数据的方法



Observable，目标或主题：

主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如添加、删除观察者以及通知观察者更新数据的方法



Product被观察类：

具体主题：具体主题是一个实现主题接口的类，该类包含了会经常发生变化的数据。而且还有一个集合，该集合存放的是观察者的引用。



 

具体观察者：具体观察者是实现了观察者接口的一个类。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，让自己成为它的观察者，或者让这个具体主题将自己从具体主题的集合中删除，使自己不在时它的观察者。

 

NameObserver名称观察者：



PriceObserver价格观察者：



测试：



 

其中Java工具类提供了被观察者抽象基类：java.util.Observable。观察者接口：java.util.Observer。

 

我们可以把观察者接口理解成事件监听接口，而被观察者对象也可当成事件源处理——换个角度来思考：监听，观察，这两个词语之间有本质的区别吗？Java事件机制的底层实现，本身就是通过观察者模式来实现的。除此之外，主题/订阅模式下的JMS本身就是观察者模式的应用。